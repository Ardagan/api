// Copyright (c) 2019 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package workflow_execution;
option go_package = "tpb";

import "enums.proto";
import "common.proto";
import "history.proto";

message WorkflowExecutionInfo {
    common.WorkflowExecution execution = 1;
    common.WorkflowType type = 2;
    int64 startTime = 3;
    int64 closeTime = 4;
    enums.WorkflowExecutionCloseStatus closeStatus = 5;
    int64 historyLength = 6;
    string parentDomainId = 7;
    common.WorkflowExecution parentExecution = 8;
    int64 executionTime = 9;
    common.Memo memo = 10;
    common.SearchAttributes searchAttributes = 11;
    common.ResetPoints autoResetPoints = 12;
}

message WorkflowExecutionConfiguration {
    common.TaskList taskList = 1;
    int32 executionStartToCloseTimeoutSeconds = 2;
    int32 taskStartToCloseTimeoutSeconds = 3;
}

message WorkflowExecutionFilter {
    string workflowId = 1;
    string runId = 2;
}

message WorkflowTypeFilter {
    string name = 1;
}

message StartTimeFilter {
    int64 earliestTime = 1;
    int64 latestTime = 2;
}

message StartWorkflowExecutionRequest {
    string domain = 1;
    string workflowId = 2;
    common.WorkflowType workflowType = 3;
    common.TaskList taskList = 4;
    bytes input = 5;
    int32 executionStartToCloseTimeoutSeconds = 6;
    int32 taskStartToCloseTimeoutSeconds = 7;
    string identity = 8;
    string requestId = 9;
    enums.WorkflowIdReusePolicy workflowIdReusePolicy = 10;
    common.RetryPolicy retryPolicy = 11;
    string cronSchedule = 12;
    common.Memo memo = 13;
    common.SearchAttributes searchAttributes = 14;
    common.Header header = 15;
}

message StartWorkflowExecutionResponse {
    string runId = 1;
}

message RequestCancelWorkflowExecutionRequest {
    string domain = 1;
    common.WorkflowExecution workflowExecution = 2;
    string identity = 3;
    string requestId = 4;
}

message RequestCancelWorkflowExecutionResponse {
}

message GetWorkflowExecutionHistoryRequest {
    string domain = 1;
    common.WorkflowExecution execution = 2;
    int32 maximumPageSize = 3;
    bytes nextPageToken = 4;
    bool waitForNewEvent = 5;
    enums.HistoryEventFilterType HistoryEventFilterType = 6;
}

message GetWorkflowExecutionHistoryResponse {
    history.History history = 1;
    bytes nextPageToken = 2;
    bool archived = 3;
}

message SignalWorkflowExecutionRequest {
    string domain = 1;
    common.WorkflowExecution workflowExecution = 2;
    string signalName = 3;
    bytes input = 4;
    string identity = 5;
    string requestId = 6;
    bytes control = 7;
}

message SignalWorkflowExecutionResponse {
}

message SignalWithStartWorkflowExecutionRequest {
    string domain = 1;
    string workflowId = 2;
    common.WorkflowType workflowType = 3;
    common.TaskList taskList = 4;
    bytes input = 5;
    int32 executionStartToCloseTimeoutSeconds = 6;
    int32 taskStartToCloseTimeoutSeconds = 7;
    string identity = 8;
    string requestId = 9;
    enums.WorkflowIdReusePolicy workflowIdReusePolicy = 10;
    string signalName = 11;
    bytes signalInput = 12;
    bytes control = 13;
    common.RetryPolicy retryPolicy = 14;
    string cronSchedule = 15;
    common.Memo memo = 16;
    common.SearchAttributes searchAttributes = 17;
    common.Header header = 18;
}

message TerminateWorkflowExecutionRequest {
    string domain = 1;
    common.WorkflowExecution workflowExecution = 2;
    string reason = 3;
    bytes details = 4;
    string identity = 5;
}

message TerminateWorkflowExecutionResponse {
}

message ResetWorkflowExecutionRequest {
    string domain = 1;
    common.WorkflowExecution workflowExecution = 2;
    string reason = 3;
    int64 decisionFinishEventId = 4;
    string requestId = 5;
}

message ResetWorkflowExecutionResponse {
    string runId = 1;
}

message ListOpenWorkflowExecutionsRequest {
    string domain = 1;
    int32 maximumPageSize = 2;
    bytes nextPageToken = 3;
    StartTimeFilter StartTimeFilter = 4;
    WorkflowExecutionFilter executionFilter = 5;
    WorkflowTypeFilter typeFilter = 6;
}

message ListOpenWorkflowExecutionsResponse {
    repeated WorkflowExecutionInfo executions = 1;
    bytes nextPageToken = 2;
}

message ListClosedWorkflowExecutionsRequest {
    string domain = 1;
    int32 maximumPageSize = 2;
    bytes nextPageToken = 3;
    StartTimeFilter StartTimeFilter = 4;
    WorkflowExecutionFilter executionFilter = 5;
    WorkflowTypeFilter typeFilter = 6;
    enums.WorkflowExecutionCloseStatus statusFilter = 7;
}

message ListClosedWorkflowExecutionsResponse {
    repeated WorkflowExecutionInfo executions = 1;
    bytes nextPageToken = 2;
}

message ListWorkflowExecutionsRequest {
    string domain = 1;
    int32 pageSize = 2;
    bytes nextPageToken = 3;
    string query = 4;
}

message ListWorkflowExecutionsResponse {
    repeated WorkflowExecutionInfo executions = 1;
    bytes nextPageToken = 2;
}

message ListArchivedWorkflowExecutionsRequest {
    string domain = 1;
    int32 pageSize = 2;
    bytes nextPageToken = 3;
    string query = 4;
}

message ListArchivedWorkflowExecutionsResponse {
    repeated WorkflowExecutionInfo executions = 1;
    bytes nextPageToken = 2;
}

message CountWorkflowExecutionsRequest {
    string domain = 1;
    string query = 2;
}

message CountWorkflowExecutionsResponse {
    int64 count = 1;
}

message PendingActivityInfo {
    string activityID = 1;
    common.ActivityType activityType = 2;
    enums.PendingActivityState state = 3;
    bytes heartbeatDetails = 4;
    int64 lastHeartbeatTimestamp = 5;
    int64 lastStartedTimestamp = 6;
    int32 attempt = 7;
    int32 maximumAttempts = 8;
    int64 scheduledTimestamp = 9;
    int64 expirationTimestamp = 10;
    string lastFailureReason = 11;
    string lastWorkerIdentity = 12;
    bytes lastFailureDetails = 13;
}

message PendingChildExecutionInfo {
    string workflowID = 1;
    string runID = 2;
    string workflowTypName = 3;
    int64 initiatedID = 4;
    enums.ParentClosePolicy parentClosePolicy = 5;
}

message DescribeWorkflowExecutionRequest {
    string domain = 1;
    common.WorkflowExecution execution = 2;
}
message DescribeWorkflowExecutionResponse {
    WorkflowExecutionConfiguration executionConfiguration = 1;
    WorkflowExecutionInfo workflowExecutionInfo = 2;
    repeated PendingActivityInfo pendingActivities = 3;
    repeated PendingChildExecutionInfo pendingChildren = 4;
}

message DescribeWorkflowExecutionAdminResponse {
    string shardId = 1;
    string historyAddr = 2;
    string mutableStateInCache = 3;
    string mutableStateInDatabase = 4;
}

message GetWorkflowExecutionRawHistoryRequest {
    string domain = 1;
    common.WorkflowExecution execution = 2;
    int64 firstEventId = 3;
    int64 nextEventId = 4;
    int32 maximumPageSize = 5;
    bytes nextPageToken = 6;
}

message GetWorkflowExecutionRawHistoryResponse {
    bytes nextPageToken = 1;
    repeated common.DataBlob historyBatches = 2;
    map<string, common.ReplicationInfo> replicationInfo = 3;
    int32 eventStoreVersion = 4;
}

/**
  * StartEventId defines the beginning of the event to fetch. The first event is exclusive.
  * EndEventId and EndEventVersion defines the end of the event to fetch. The end event is exclusive.
  **/
message GetWorkflowExecutionRawHistoryV2Request {
    string domain = 1;
    common.WorkflowExecution execution = 2;
    int64 startEventId = 3;
    int64 startEventVersion = 4;
    int64 endEventId = 5;
    int64 endEventVersion = 6;
    int32 maximumPageSize = 7;
    bytes nextPageToken = 8;
}

message GetWorkflowExecutionRawHistoryV2Response {
    bytes nextPageToken = 1;
    repeated common.DataBlob historyBatches = 2;
    common.VersionHistory versionHistory = 3;
}
